<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sai-Model: SaiModel::SaiModel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Sai-Model<span id="projectnumber">&#160;v1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>SaiModel</b></li><li class="navelem"><a class="el" href="classSaiModel_1_1SaiModel.html">SaiModel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSaiModel_1_1SaiModel-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SaiModel::SaiModel Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class represents a robot kinematic and dynamic model and provides methods to compute many useful robot quantities, such as positions, velocities, jacobians, operational space matrices, grasp matrices, etc.  
 <a href="classSaiModel_1_1SaiModel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SaiModel_8h_source.html">SaiModel.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3231f5bd04e9e67f3287c3cf942892db" id="r_a3231f5bd04e9e67f3287c3cf942892db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a3231f5bd04e9e67f3287c3cf942892db">SaiModel</a> (const string path_to_model_file, bool verbose=false)</td></tr>
<tr class="memdesc:a3231f5bd04e9e67f3287c3cf942892db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Sai 2 Model object from a URDF file.  <br /></td></tr>
<tr class="separator:a3231f5bd04e9e67f3287c3cf942892db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2914917f8d83b23ce91cebf52f5b15f5" id="r_a2914917f8d83b23ce91cebf52f5b15f5"><td class="memItemLeft" align="right" valign="top"><a id="a2914917f8d83b23ce91cebf52f5b15f5" name="a2914917f8d83b23ce91cebf52f5b15f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SaiModel</b> (<a class="el" href="classSaiModel_1_1SaiModel.html">SaiModel</a> const &amp;)=delete</td></tr>
<tr class="separator:a2914917f8d83b23ce91cebf52f5b15f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9d31061d15f83a29bcbb230d566039" id="r_a3c9d31061d15f83a29bcbb230d566039"><td class="memItemLeft" align="right" valign="top"><a id="a3c9d31061d15f83a29bcbb230d566039" name="a3c9d31061d15f83a29bcbb230d566039"></a>
<a class="el" href="classSaiModel_1_1SaiModel.html">SaiModel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classSaiModel_1_1SaiModel.html">SaiModel</a> const &amp;)=delete</td></tr>
<tr class="separator:a3c9d31061d15f83a29bcbb230d566039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a3a7af4397141327430bf72f4bd7c5" id="r_a40a3a7af4397141327430bf72f4bd7c5"><td class="memItemLeft" align="right" valign="top"><a id="a40a3a7af4397141327430bf72f4bd7c5" name="a40a3a7af4397141327430bf72f4bd7c5"></a>
const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>q</b> () const</td></tr>
<tr class="memdesc:a40a3a7af4397141327430bf72f4bd7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for joint positions <br /></td></tr>
<tr class="separator:a40a3a7af4397141327430bf72f4bd7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c77189e913c63d1b4c42164bba6436" id="r_a05c77189e913c63d1b4c42164bba6436"><td class="memItemLeft" align="right" valign="top"><a id="a05c77189e913c63d1b4c42164bba6436" name="a05c77189e913c63d1b4c42164bba6436"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setQ</b> (const Eigen::VectorXd &amp;<a class="el" href="classSaiModel_1_1SaiModel.html#a40a3a7af4397141327430bf72f4bd7c5">q</a>)</td></tr>
<tr class="memdesc:a05c77189e913c63d1b4c42164bba6436"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter for joint positions <br /></td></tr>
<tr class="separator:a05c77189e913c63d1b4c42164bba6436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e7a78b64a67cd580208ba983b8e5bc" id="r_a84e7a78b64a67cd580208ba983b8e5bc"><td class="memItemLeft" align="right" valign="top"><a id="a84e7a78b64a67cd580208ba983b8e5bc" name="a84e7a78b64a67cd580208ba983b8e5bc"></a>
const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>dq</b> () const</td></tr>
<tr class="memdesc:a84e7a78b64a67cd580208ba983b8e5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for joint velocities <br /></td></tr>
<tr class="separator:a84e7a78b64a67cd580208ba983b8e5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66139e36809f9971dc1cfc3fea259bc0" id="r_a66139e36809f9971dc1cfc3fea259bc0"><td class="memItemLeft" align="right" valign="top"><a id="a66139e36809f9971dc1cfc3fea259bc0" name="a66139e36809f9971dc1cfc3fea259bc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDq</b> (const Eigen::VectorXd &amp;<a class="el" href="classSaiModel_1_1SaiModel.html#a84e7a78b64a67cd580208ba983b8e5bc">dq</a>)</td></tr>
<tr class="memdesc:a66139e36809f9971dc1cfc3fea259bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter for joint velocities <br /></td></tr>
<tr class="separator:a66139e36809f9971dc1cfc3fea259bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acafeed5fafefe08d1daa1bad1e1a1e" id="r_a8acafeed5fafefe08d1daa1bad1e1a1e"><td class="memItemLeft" align="right" valign="top"><a id="a8acafeed5fafefe08d1daa1bad1e1a1e" name="a8acafeed5fafefe08d1daa1bad1e1a1e"></a>
const Eigen::Quaterniond&#160;</td><td class="memItemRight" valign="bottom"><b>sphericalQuat</b> (const std::string &amp;joint_name) const</td></tr>
<tr class="memdesc:a8acafeed5fafefe08d1daa1bad1e1a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the quaternion representation of a spherical joint by name. <br /></td></tr>
<tr class="separator:a8acafeed5fafefe08d1daa1bad1e1a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed437d80e29ee682020e70f3bd66e9a" id="r_a3ed437d80e29ee682020e70f3bd66e9a"><td class="memItemLeft" align="right" valign="top"><a id="a3ed437d80e29ee682020e70f3bd66e9a" name="a3ed437d80e29ee682020e70f3bd66e9a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSphericalQuat</b> (const std::string &amp;joint_name, Eigen::Quaterniond quat)</td></tr>
<tr class="memdesc:a3ed437d80e29ee682020e70f3bd66e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the quaternion representation of a spherical joint by name. <br /></td></tr>
<tr class="separator:a3ed437d80e29ee682020e70f3bd66e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb44dacd8c86fc5f913f48f18691b03" id="r_aedb44dacd8c86fc5f913f48f18691b03"><td class="memItemLeft" align="right" valign="top"><a id="aedb44dacd8c86fc5f913f48f18691b03" name="aedb44dacd8c86fc5f913f48f18691b03"></a>
const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ddq</b> () const</td></tr>
<tr class="memdesc:aedb44dacd8c86fc5f913f48f18691b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for joint accelerations <br /></td></tr>
<tr class="separator:aedb44dacd8c86fc5f913f48f18691b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af589ef167b35870905e98dc66fe000a2" id="r_af589ef167b35870905e98dc66fe000a2"><td class="memItemLeft" align="right" valign="top"><a id="af589ef167b35870905e98dc66fe000a2" name="af589ef167b35870905e98dc66fe000a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDdq</b> (const Eigen::VectorXd &amp;<a class="el" href="classSaiModel_1_1SaiModel.html#aedb44dacd8c86fc5f913f48f18691b03">ddq</a>)</td></tr>
<tr class="memdesc:af589ef167b35870905e98dc66fe000a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter for joint accelerations <br /></td></tr>
<tr class="separator:af589ef167b35870905e98dc66fe000a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7b78f02d13ad77639b15f8700587fd" id="r_a0f7b78f02d13ad77639b15f8700587fd"><td class="memItemLeft" align="right" valign="top"><a id="a0f7b78f02d13ad77639b15f8700587fd" name="a0f7b78f02d13ad77639b15f8700587fd"></a>
const Eigen::MatrixXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>M</b> () const</td></tr>
<tr class="memdesc:a0f7b78f02d13ad77639b15f8700587fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for the joint space mass matrix <br /></td></tr>
<tr class="separator:a0f7b78f02d13ad77639b15f8700587fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff3cf47aa5412b34bcb0a734361255" id="r_abdff3cf47aa5412b34bcb0a734361255"><td class="memItemLeft" align="right" valign="top"><a id="abdff3cf47aa5412b34bcb0a734361255" name="abdff3cf47aa5412b34bcb0a734361255"></a>
const Eigen::MatrixXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>MInv</b> () const</td></tr>
<tr class="memdesc:abdff3cf47aa5412b34bcb0a734361255"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for the inverse of the joint space mass matrix <br /></td></tr>
<tr class="separator:abdff3cf47aa5412b34bcb0a734361255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd911ac7c09d63a538615228ec557c" id="r_abefd911ac7c09d63a538615228ec557c"><td class="memItemLeft" align="right" valign="top"><a id="abefd911ac7c09d63a538615228ec557c" name="abefd911ac7c09d63a538615228ec557c"></a>
const Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>worldGravity</b> () const</td></tr>
<tr class="memdesc:abefd911ac7c09d63a538615228ec557c"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for the 3D world gravity vector <br /></td></tr>
<tr class="separator:abefd911ac7c09d63a538615228ec557c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1b305f7f4516f5d827f896e4941e44" id="r_acc1b305f7f4516f5d827f896e4941e44"><td class="memItemLeft" align="right" valign="top"><a id="acc1b305f7f4516f5d827f896e4941e44" name="acc1b305f7f4516f5d827f896e4941e44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setWorldGravity</b> (const Vector3d &amp;world_gravity)</td></tr>
<tr class="memdesc:acc1b305f7f4516f5d827f896e4941e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter for the 3D world gravity vector <br /></td></tr>
<tr class="separator:acc1b305f7f4516f5d827f896e4941e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740218bdf928e9f67735e6316c86a209" id="r_a740218bdf928e9f67735e6316c86a209"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structSaiModel_1_1JointLimit.html">JointLimit</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a740218bdf928e9f67735e6316c86a209">jointLimits</a> () const</td></tr>
<tr class="memdesc:a740218bdf928e9f67735e6316c86a209"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for the joint limits  <br /></td></tr>
<tr class="separator:a740218bdf928e9f67735e6316c86a209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cafebfcd3302cbb9976db4af1ac3685" id="r_a9cafebfcd3302cbb9976db4af1ac3685"><td class="memItemLeft" align="right" valign="top"><a id="a9cafebfcd3302cbb9976db4af1ac3685" name="a9cafebfcd3302cbb9976db4af1ac3685"></a>
VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>jointLimitsPositionLower</b> () const</td></tr>
<tr class="memdesc:a9cafebfcd3302cbb9976db4af1ac3685"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for the upper position of all joints as a VectorXd of size q_size for continuous joints, the limits are set to +numeric_limits&lt;double&gt;::max(). for spherical joints, the limits of all the corresponding quaternion coefficients are set to +1. <br /></td></tr>
<tr class="separator:a9cafebfcd3302cbb9976db4af1ac3685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa660595d85363872dfb4a04e254ee03c" id="r_aa660595d85363872dfb4a04e254ee03c"><td class="memItemLeft" align="right" valign="top"><a id="aa660595d85363872dfb4a04e254ee03c" name="aa660595d85363872dfb4a04e254ee03c"></a>
VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>jointLimitsPositionUpper</b> () const</td></tr>
<tr class="memdesc:aa660595d85363872dfb4a04e254ee03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for the lower position of all joints as a VectorXd of size q_size for continuous joints, the limits are set to -numeric_limits&lt;double&gt;::max(). for spherical joints, the limits of all the corresponding quaternion coefficients are set to -1. <br /></td></tr>
<tr class="separator:aa660595d85363872dfb4a04e254ee03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec243b884c143ad75ecf14c202df9e6" id="r_a6ec243b884c143ad75ecf14c202df9e6"><td class="memItemLeft" align="right" valign="top"><a id="a6ec243b884c143ad75ecf14c202df9e6" name="a6ec243b884c143ad75ecf14c202df9e6"></a>
const std::vector&lt; <a class="el" href="structSaiModel_1_1SphericalJointDescription.html">SphericalJointDescription</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sphericalJoints</b> () const</td></tr>
<tr class="memdesc:a6ec243b884c143ad75ecf14c202df9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a vector of SphereicalJointDescription structures, one per spherical joint in the model <br /></td></tr>
<tr class="separator:a6ec243b884c143ad75ecf14c202df9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09164bab3bf43d6083cfb29f9291defb" id="r_a09164bab3bf43d6083cfb29f9291defb"><td class="memItemLeft" align="right" valign="top"><a id="a09164bab3bf43d6083cfb29f9291defb" name="a09164bab3bf43d6083cfb29f9291defb"></a>
const Eigen::Affine3d &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>TRobotBase</b> () const</td></tr>
<tr class="memdesc:a09164bab3bf43d6083cfb29f9291defb"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter for the robot base transform. This is the robot base pose with respect to the world frame <br /></td></tr>
<tr class="separator:a09164bab3bf43d6083cfb29f9291defb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e61fa91ac86915867ac1ef13df4cd7e" id="r_a2e61fa91ac86915867ac1ef13df4cd7e"><td class="memItemLeft" align="right" valign="top"><a id="a2e61fa91ac86915867ac1ef13df4cd7e" name="a2e61fa91ac86915867ac1ef13df4cd7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTRobotBase</b> (const Affine3d &amp;T)</td></tr>
<tr class="memdesc:a2e61fa91ac86915867ac1ef13df4cd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">setter for the robot base transform. This is the robot base pose with respect to the world frame <br /></td></tr>
<tr class="separator:a2e61fa91ac86915867ac1ef13df4cd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bc9a5adec92c6b65dfc5453cc3ec6d" id="r_a60bc9a5adec92c6b65dfc5453cc3ec6d"><td class="memItemLeft" align="right" valign="top"><a id="a60bc9a5adec92c6b65dfc5453cc3ec6d" name="a60bc9a5adec92c6b65dfc5453cc3ec6d"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>jointNames</b> () const</td></tr>
<tr class="memdesc:a60bc9a5adec92c6b65dfc5453cc3ec6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a vector of all the joint names in the model <br /></td></tr>
<tr class="separator:a60bc9a5adec92c6b65dfc5453cc3ec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f267753af8146d643642c6e2f5df7c" id="r_ae6f267753af8146d643642c6e2f5df7c"><td class="memItemLeft" align="right" valign="top"><a id="ae6f267753af8146d643642c6e2f5df7c" name="ae6f267753af8146d643642c6e2f5df7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isLinkInRobot</b> (const std::string &amp;link_name) const</td></tr>
<tr class="memdesc:ae6f267753af8146d643642c6e2f5df7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the given link is part of the robot <br /></td></tr>
<tr class="separator:ae6f267753af8146d643642c6e2f5df7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9d73d4458374ff0cc91f6ee01af595" id="r_a6b9d73d4458374ff0cc91f6ee01af595"><td class="memItemLeft" align="right" valign="top"><a id="a6b9d73d4458374ff0cc91f6ee01af595" name="a6b9d73d4458374ff0cc91f6ee01af595"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateKinematics</b> ()</td></tr>
<tr class="memdesc:a6b9d73d4458374ff0cc91f6ee01af595"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the kinematics (needed to have up to date positions, velocities and jacobians) for the current robot configuration. <br /></td></tr>
<tr class="separator:a6b9d73d4458374ff0cc91f6ee01af595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e499dc1098bf78f7aaeaabf6f10ab8" id="r_ab8e499dc1098bf78f7aaeaabf6f10ab8"><td class="memItemLeft" align="right" valign="top"><a id="ab8e499dc1098bf78f7aaeaabf6f10ab8" name="ab8e499dc1098bf78f7aaeaabf6f10ab8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateModel</b> ()</td></tr>
<tr class="memdesc:ab8e499dc1098bf78f7aaeaabf6f10ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the kinematics and dynamics (mass matrix and its inverse) for the current robot configuration. <br /></td></tr>
<tr class="separator:ab8e499dc1098bf78f7aaeaabf6f10ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29311864a2a56ba2082d32f69e5f824" id="r_aa29311864a2a56ba2082d32f69e5f824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aa29311864a2a56ba2082d32f69e5f824">updateModel</a> (const Eigen::MatrixXd &amp;<a class="el" href="classSaiModel_1_1SaiModel.html#a0f7b78f02d13ad77639b15f8700587fd">M</a>)</td></tr>
<tr class="memdesc:aa29311864a2a56ba2082d32f69e5f824"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the kinematics and the inverse of the mass matrix with an externally provided mass matrix (for example from the robot's manufacturer API) insetad of computing the mass matrix from the urdf description of the robot.  <br /></td></tr>
<tr class="separator:aa29311864a2a56ba2082d32f69e5f824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab22a8ce4966e1186623d9171e50d9dd" id="r_aab22a8ce4966e1186623d9171e50d9dd"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aab22a8ce4966e1186623d9171e50d9dd">dof</a> () const</td></tr>
<tr class="memdesc:aab22a8ce4966e1186623d9171e50d9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of degrees of freedom of the robot  <br /></td></tr>
<tr class="separator:aab22a8ce4966e1186623d9171e50d9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e246bd3b6c7ebcc5266f8a0f3e7633" id="r_ae9e246bd3b6c7ebcc5266f8a0f3e7633"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ae9e246bd3b6c7ebcc5266f8a0f3e7633">qSize</a> () const</td></tr>
<tr class="memdesc:ae9e246bd3b6c7ebcc5266f8a0f3e7633"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of values required for robot joint positions description. equals dof unless spherical or floating joints are present.  <br /></td></tr>
<tr class="separator:ae9e246bd3b6c7ebcc5266f8a0f3e7633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53c3862eccb309de7640a8c0cc7c8f8" id="r_aa53c3862eccb309de7640a8c0cc7c8f8"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aa53c3862eccb309de7640a8c0cc7c8f8">jointGravityVector</a> ()</td></tr>
<tr class="memdesc:aa53c3862eccb309de7640a8c0cc7c8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes and returns the joint gravity vector for the last updated configuration. This is the vector of torques required to compensate for the gravity forces acting on the robot.  <br /></td></tr>
<tr class="separator:aa53c3862eccb309de7640a8c0cc7c8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de5bfad3ff71784bbc67be1e06c6fd0" id="r_a4de5bfad3ff71784bbc67be1e06c6fd0"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a4de5bfad3ff71784bbc67be1e06c6fd0">coriolisForce</a> ()</td></tr>
<tr class="memdesc:a4de5bfad3ff71784bbc67be1e06c6fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes and returns the joint coriolis and centrifugal forces of the last updated configuration  <br /></td></tr>
<tr class="separator:a4de5bfad3ff71784bbc67be1e06c6fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2af6f58d7cc1769e3aa84448e9aa87" id="r_a6c2af6f58d7cc1769e3aa84448e9aa87"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a6c2af6f58d7cc1769e3aa84448e9aa87">coriolisPlusGravity</a> ()</td></tr>
<tr class="memdesc:a6c2af6f58d7cc1769e3aa84448e9aa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the non linear effects of the robot dynamics. That is to say the gravity plus the coriolis and centrifugal forces.  <br /></td></tr>
<tr class="separator:a6c2af6f58d7cc1769e3aa84448e9aa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf7a15e51067a46ad88c3c7847c295b" id="r_a3cf7a15e51067a46ad88c3c7847c295b"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a3cf7a15e51067a46ad88c3c7847c295b">factorizedChristoffelMatrix</a> ()</td></tr>
<tr class="memdesc:a3cf7a15e51067a46ad88c3c7847c295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix C such that the coriolis and centrifucal forces can be expressed b = C*q_dot.  <br /></td></tr>
<tr class="separator:a3cf7a15e51067a46ad88c3c7847c295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0499397118327680b13833fe90638e" id="r_a1c0499397118327680b13833fe90638e"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a1c0499397118327680b13833fe90638e">J</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:a1c0499397118327680b13833fe90638e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full jacobian for link, relative to base (id=0) in the form [Jv; Jw] (angular first, linear next) expressed in robot base frame.  <br /></td></tr>
<tr class="separator:a1c0499397118327680b13833fe90638e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0ba0a238efa96f833fc0368a181ff9" id="r_a6f0ba0a238efa96f833fc0368a181ff9"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a6f0ba0a238efa96f833fc0368a181ff9">JWorldFrame</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:a6f0ba0a238efa96f833fc0368a181ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the J function, but the returned jacobian is expressed in the world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a6f0ba0a238efa96f833fc0368a181ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a3928244fb207fdac9d308df470665" id="r_ae3a3928244fb207fdac9d308df470665"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ae3a3928244fb207fdac9d308df470665">JLocalFrame</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero(), const Matrix3d &amp;rot_in_link=Matrix3d::Identity()) const</td></tr>
<tr class="memdesc:ae3a3928244fb207fdac9d308df470665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the J function, but the returned jacobian is expressed in a local frame (with respect to the link frame) instead of the robot base frame.  <br /></td></tr>
<tr class="separator:ae3a3928244fb207fdac9d308df470665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6752408d68c17361a04e25ec42e393a" id="r_ab6752408d68c17361a04e25ec42e393a"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ab6752408d68c17361a04e25ec42e393a">Jv</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:ab6752408d68c17361a04e25ec42e393a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity jacobian for link, relative to base (id=0) expressed in robot base frame.  <br /></td></tr>
<tr class="separator:ab6752408d68c17361a04e25ec42e393a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c4ccb90f9f30709e1cfc4c3d26cb3" id="r_ae67c4ccb90f9f30709e1cfc4c3d26cb3"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ae67c4ccb90f9f30709e1cfc4c3d26cb3">JvWorldFrame</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:ae67c4ccb90f9f30709e1cfc4c3d26cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the Jv function, but the returned jacobian is expressed in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:ae67c4ccb90f9f30709e1cfc4c3d26cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab36f364dfb5ac7d7f264d6de16788bf" id="r_aab36f364dfb5ac7d7f264d6de16788bf"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aab36f364dfb5ac7d7f264d6de16788bf">JvLocalFrame</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero(), const Matrix3d &amp;rot_in_link=Matrix3d::Identity()) const</td></tr>
<tr class="memdesc:aab36f364dfb5ac7d7f264d6de16788bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the Jv function, but the returned jacobian is expressed in a local frame (with respect to the link frame) instead of the robot base frame.  <br /></td></tr>
<tr class="separator:aab36f364dfb5ac7d7f264d6de16788bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbddeb81f4a996a6c903f6b755f65ef" id="r_a7cbddeb81f4a996a6c903f6b755f65ef"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a7cbddeb81f4a996a6c903f6b755f65ef">Jw</a> (const string &amp;link_name) const</td></tr>
<tr class="memdesc:a7cbddeb81f4a996a6c903f6b755f65ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular velocity jacobian for link, relative to base (id=0) expressed in robot base frame.  <br /></td></tr>
<tr class="separator:a7cbddeb81f4a996a6c903f6b755f65ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ca115e04ad10b592f3cc610497333" id="r_a297ca115e04ad10b592f3cc610497333"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a297ca115e04ad10b592f3cc610497333">JwWorldFrame</a> (const string &amp;link_name) const</td></tr>
<tr class="memdesc:a297ca115e04ad10b592f3cc610497333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the Jw function, but the returned jacobian is expressed in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a297ca115e04ad10b592f3cc610497333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f09f8ffca0259d235cb3a641dfa11e" id="r_a66f09f8ffca0259d235cb3a641dfa11e"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a66f09f8ffca0259d235cb3a641dfa11e">JwLocalFrame</a> (const string &amp;link_name, const Matrix3d &amp;rot_in_link=Matrix3d::Identity()) const</td></tr>
<tr class="memdesc:a66f09f8ffca0259d235cb3a641dfa11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the Jw function, but the returned jacobian is expressed in a local frame (with respect to the link frame) instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a66f09f8ffca0259d235cb3a641dfa11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e714659dd9956022f3a3aff3021269" id="r_af7e714659dd9956022f3a3aff3021269"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#af7e714659dd9956022f3a3aff3021269">computeInverseKinematics</a> (const vector&lt; string &gt; &amp;link_names, const vector&lt; Vector3d &gt; &amp;pos_in_links, const vector&lt; Vector3d &gt; &amp;desired_pos_world_frame)</td></tr>
<tr class="memdesc:af7e714659dd9956022f3a3aff3021269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse kinematics to get the robot configuration that matches a set of points on the robot to desired positions. Uses a modified underlying RBDL function based on an iterative computation using the damped Levenberg-Marquardt method (also known as Damped Least Squares method) with output saturation for the joint limits. Always returns the value from the last iteration, even if the IK did not converge. Uses the current joint positions as initial guess, and does not update the robot configuration.  <br /></td></tr>
<tr class="separator:af7e714659dd9956022f3a3aff3021269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca249ca7d43eff87fcf2936c5c4ca55" id="r_adca249ca7d43eff87fcf2936c5c4ca55"><td class="memItemLeft" align="right" valign="top">VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#adca249ca7d43eff87fcf2936c5c4ca55">computeInverseKinematics</a> (const vector&lt; string &gt; &amp;link_names, const vector&lt; Affine3d &gt; &amp;frames_in_links, const vector&lt; Affine3d &gt; &amp;desired_frames_locations_in_world_frame)</td></tr>
<tr class="memdesc:adca249ca7d43eff87fcf2936c5c4ca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse kinematics to get the robot configuration that matches a set of frames on some robot links to a set of desired frames. Uses the same underlying function as the previous function, but with frames instead of points. Uses the current joint positions as initial guess, and does not update the robot configuration.  <br /></td></tr>
<tr class="separator:adca249ca7d43eff87fcf2936c5c4ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ccfe97cc02632c0c1f66db1dcb1ce0" id="r_a77ccfe97cc02632c0c1f66db1dcb1ce0"><td class="memItemLeft" align="right" valign="top">Affine3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a77ccfe97cc02632c0c1f66db1dcb1ce0">transform</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero(), const Matrix3d &amp;rot_in_link=Matrix3d::Identity()) const</td></tr>
<tr class="memdesc:a77ccfe97cc02632c0c1f66db1dcb1ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">transformation from base to link frame (possibly a local frame expressed in link frame), in robot base base coordinates. This represents the operator that "moves" the base frame to the link frame, which also means it represents the coordinate transform matrix to express a point in base frame, if we know it in link frame: p_base = T * p_link  <br /></td></tr>
<tr class="separator:a77ccfe97cc02632c0c1f66db1dcb1ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb999cbdf225cb5d330d456debfc32d" id="r_a5cb999cbdf225cb5d330d456debfc32d"><td class="memItemLeft" align="right" valign="top">Affine3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a5cb999cbdf225cb5d330d456debfc32d">transformInWorld</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero(), const Matrix3d &amp;rot_in_link=Matrix3d::Identity()) const</td></tr>
<tr class="memdesc:a5cb999cbdf225cb5d330d456debfc32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the transform function, but the returned transformation is expressed in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a5cb999cbdf225cb5d330d456debfc32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9808cb34661b443a1d66dc6fe4e55ec7" id="r_a9808cb34661b443a1d66dc6fe4e55ec7"><td class="memItemLeft" align="right" valign="top">Vector6d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a9808cb34661b443a1d66dc6fe4e55ec7">velocity6d</a> (const string link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:a9808cb34661b443a1d66dc6fe4e55ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear and angular velocity of a point in a link. The returned value is expressed in the base frame and is of the form [v; w] (linear first, angular next)  <br /></td></tr>
<tr class="separator:a9808cb34661b443a1d66dc6fe4e55ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e109198073a151d82b2e3541e70f764" id="r_a6e109198073a151d82b2e3541e70f764"><td class="memItemLeft" align="right" valign="top">Vector6d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a6e109198073a151d82b2e3541e70f764">velocity6dInWorld</a> (const string link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:a6e109198073a151d82b2e3541e70f764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the velocity6d function, but the returned velocity is in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a6e109198073a151d82b2e3541e70f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae208a7b8f61fe99b48082340bdf5f0f0" id="r_ae208a7b8f61fe99b48082340bdf5f0f0"><td class="memItemLeft" align="right" valign="top">Vector6d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ae208a7b8f61fe99b48082340bdf5f0f0">acceleration6d</a> (const string link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:ae208a7b8f61fe99b48082340bdf5f0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear and angular acceleration of a point in a link. The returned value is expressed in the base frame and is of the form [a; alpha] (linear first, angular next). Note: Acceleration computations are very sensitive to frames being correct. So it is safer to call UpdateKinematics before calling this.  <br /></td></tr>
<tr class="separator:ae208a7b8f61fe99b48082340bdf5f0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f15ca2a0abb8307032cf435be21b28e" id="r_a4f15ca2a0abb8307032cf435be21b28e"><td class="memItemLeft" align="right" valign="top">Vector6d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a4f15ca2a0abb8307032cf435be21b28e">acceleration6dInWorld</a> (const string link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:a4f15ca2a0abb8307032cf435be21b28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the acceleration6d function, but the returned acceleration is in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a4f15ca2a0abb8307032cf435be21b28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09dc9ccd7e2dfa67f386ed82f52c5a1" id="r_aa09dc9ccd7e2dfa67f386ed82f52c5a1"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aa09dc9ccd7e2dfa67f386ed82f52c5a1">position</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:aa09dc9ccd7e2dfa67f386ed82f52c5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the position of a point in a link. The returned value is in the base frame by default.  <br /></td></tr>
<tr class="separator:aa09dc9ccd7e2dfa67f386ed82f52c5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ff3c898a809cb1752a6271286424a5" id="r_aa0ff3c898a809cb1752a6271286424a5"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aa0ff3c898a809cb1752a6271286424a5">positionInWorld</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:aa0ff3c898a809cb1752a6271286424a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the position function, but the returned position is in a world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:aa0ff3c898a809cb1752a6271286424a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6038147a812a7509c39034301bb801" id="r_abf6038147a812a7509c39034301bb801"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#abf6038147a812a7509c39034301bb801">linearVelocity</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:abf6038147a812a7509c39034301bb801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the velocity of point in link, in base coordinates.  <br /></td></tr>
<tr class="separator:abf6038147a812a7509c39034301bb801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc094072c7d224b0361cf95f62ea21b" id="r_a1bc094072c7d224b0361cf95f62ea21b"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a1bc094072c7d224b0361cf95f62ea21b">linearVelocityInWorld</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:a1bc094072c7d224b0361cf95f62ea21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the linearVelocity function, but the returned velocity is in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a1bc094072c7d224b0361cf95f62ea21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29be2741c8177c43361d26cebce1e0e8" id="r_a29be2741c8177c43361d26cebce1e0e8"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a29be2741c8177c43361d26cebce1e0e8">linearAcceleration</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:a29be2741c8177c43361d26cebce1e0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the acceleration of point in link, in base coordinates Note: Acceleration computations are very sensitive to frames being correct. So it is safer to call UpdateKinematics before calling this, unless this is called right after a simulator integrator state.  <br /></td></tr>
<tr class="separator:a29be2741c8177c43361d26cebce1e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee710a5bd2f489a20805cbfe7d2e9dd" id="r_adee710a5bd2f489a20805cbfe7d2e9dd"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#adee710a5bd2f489a20805cbfe7d2e9dd">linearAccelerationInWorld</a> (const string &amp;link_name, const Vector3d &amp;pos_in_link=Vector3d::Zero()) const</td></tr>
<tr class="memdesc:adee710a5bd2f489a20805cbfe7d2e9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the linearAcceleration function, but the returned acceleration is in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:adee710a5bd2f489a20805cbfe7d2e9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868f5a5c5fd596db3b3f7853e7183905" id="r_a868f5a5c5fd596db3b3f7853e7183905"><td class="memItemLeft" align="right" valign="top">Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a868f5a5c5fd596db3b3f7853e7183905">rotation</a> (const string &amp;link_name, const Matrix3d &amp;rot_in_link=Matrix3d::Identity()) const</td></tr>
<tr class="memdesc:a868f5a5c5fd596db3b3f7853e7183905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rotation of a link (possibly a local frame expressed in link frame) with respect to base frame.  <br /></td></tr>
<tr class="separator:a868f5a5c5fd596db3b3f7853e7183905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb949c8cc13d5a10023fb3c307a6352" id="r_a0bb949c8cc13d5a10023fb3c307a6352"><td class="memItemLeft" align="right" valign="top">Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a0bb949c8cc13d5a10023fb3c307a6352">rotationInWorld</a> (const string &amp;link_name, const Matrix3d &amp;rot_in_link=Matrix3d::Identity()) const</td></tr>
<tr class="memdesc:a0bb949c8cc13d5a10023fb3c307a6352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the rotation function, but the returned rotation is in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a0bb949c8cc13d5a10023fb3c307a6352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bdf402ecf3b450c38a1c7376a5419e" id="r_a36bdf402ecf3b450c38a1c7376a5419e"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a36bdf402ecf3b450c38a1c7376a5419e">angularVelocity</a> (const string &amp;link_name) const</td></tr>
<tr class="memdesc:a36bdf402ecf3b450c38a1c7376a5419e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the angular Velocity of a link (possibly a local frame expressed in link frame) with respect to base frame (default)  <br /></td></tr>
<tr class="separator:a36bdf402ecf3b450c38a1c7376a5419e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0209c1c46fa9006ddbec1443109c394" id="r_ad0209c1c46fa9006ddbec1443109c394"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ad0209c1c46fa9006ddbec1443109c394">angularVelocityInWorld</a> (const string &amp;link_name) const</td></tr>
<tr class="memdesc:ad0209c1c46fa9006ddbec1443109c394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the angularVelocity function, but the returned angular velocity is in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:ad0209c1c46fa9006ddbec1443109c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04cf4a2821952b69413c9ce43017529" id="r_af04cf4a2821952b69413c9ce43017529"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#af04cf4a2821952b69413c9ce43017529">angularAcceleration</a> (const string &amp;link_name) const</td></tr>
<tr class="memdesc:af04cf4a2821952b69413c9ce43017529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the angular Acceleration of a link (possibly a local frame expressed in link frame) with respect to base frame Note: Acceleration computations are very sensitive to frames being correct. So it is safer to call UpdateKinematics before calling this, unless this is called right after a simulator integrator state.  <br /></td></tr>
<tr class="separator:af04cf4a2821952b69413c9ce43017529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025c0ca2d45c7d3a5e978dca3753207d" id="r_a025c0ca2d45c7d3a5e978dca3753207d"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a025c0ca2d45c7d3a5e978dca3753207d">angularAccelerationInWorld</a> (const string &amp;link_name) const</td></tr>
<tr class="memdesc:a025c0ca2d45c7d3a5e978dca3753207d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the angularAcceleration function, but the returned angular acceleration is in world frame instead of the robot base frame.  <br /></td></tr>
<tr class="separator:a025c0ca2d45c7d3a5e978dca3753207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ec4fb2f3a20dc55ac34c3c98b7eaac" id="r_a65ec4fb2f3a20dc55ac34c3c98b7eaac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a65ec4fb2f3a20dc55ac34c3c98b7eaac">jointIndex</a> (const string &amp;joint_name) const</td></tr>
<tr class="memdesc:a65ec4fb2f3a20dc55ac34c3c98b7eaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the joint index for a given name. For spherical joints, returns the first index of the vector part of the quaternion.  <br /></td></tr>
<tr class="separator:a65ec4fb2f3a20dc55ac34c3c98b7eaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab856039203502de4ee4fb2c294e9d338" id="r_ab856039203502de4ee4fb2c294e9d338"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ab856039203502de4ee4fb2c294e9d338">sphericalJointIndexW</a> (const string &amp;joint_name) const</td></tr>
<tr class="memdesc:ab856039203502de4ee4fb2c294e9d338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the scalar part of the quaternion for a spherical joint. Throws an error if the joint is not spherical.  <br /></td></tr>
<tr class="separator:ab856039203502de4ee4fb2c294e9d338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7b9df768c2e4eaa547d181ca3984fe" id="r_abd7b9df768c2e4eaa547d181ca3984fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#abd7b9df768c2e4eaa547d181ca3984fe">jointName</a> (const int joint_id) const</td></tr>
<tr class="memdesc:abd7b9df768c2e4eaa547d181ca3984fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the joint name for the given index (for spherical joints, any index corresponding to the position of one of the quaternion coefficients will return the spherical joint name)  <br /></td></tr>
<tr class="separator:abd7b9df768c2e4eaa547d181ca3984fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcba7dc8f3fc764e81237bae7a0e38c9" id="r_adcba7dc8f3fc764e81237bae7a0e38c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#adcba7dc8f3fc764e81237bae7a0e38c9">childLinkName</a> (const std::string &amp;joint_name) const</td></tr>
<tr class="memdesc:adcba7dc8f3fc764e81237bae7a0e38c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the link directly attached to the given joint id.  <br /></td></tr>
<tr class="separator:adcba7dc8f3fc764e81237bae7a0e38c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e2133ede2458d440dcf1457b25ca69" id="r_a01e2133ede2458d440dcf1457b25ca69"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a01e2133ede2458d440dcf1457b25ca69">parentLinkName</a> (const std::string &amp;joint_name) const</td></tr>
<tr class="memdesc:a01e2133ede2458d440dcf1457b25ca69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the link name parent of the given joint id.  <br /></td></tr>
<tr class="separator:a01e2133ede2458d440dcf1457b25ca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecad858b6bebd2fc94552827559c3ef" id="r_acecad858b6bebd2fc94552827559c3ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSaiModel_1_1LinkMassParams.html">LinkMassParams</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#acecad858b6bebd2fc94552827559c3ef">getLinkMassParams</a> (const string &amp;link_name) const</td></tr>
<tr class="memdesc:acecad858b6bebd2fc94552827559c3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the mass properties of a given link.  <br /></td></tr>
<tr class="separator:acecad858b6bebd2fc94552827559c3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05741c173421d5963206573ce2625119" id="r_a05741c173421d5963206573ce2625119"><td class="memItemLeft" align="right" valign="top"><a id="a05741c173421d5963206573ce2625119" name="a05741c173421d5963206573ce2625119"></a>
Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>comPosition</b> () const</td></tr>
<tr class="memdesc:a05741c173421d5963206573ce2625119"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the position of the center of mass of the robot in robot base frame <br /></td></tr>
<tr class="separator:a05741c173421d5963206573ce2625119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac623fce02968881a5323c5892fed70fb" id="r_ac623fce02968881a5323c5892fed70fb"><td class="memItemLeft" align="right" valign="top"><a id="ac623fce02968881a5323c5892fed70fb" name="ac623fce02968881a5323c5892fed70fb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>comJacobian</b> () const</td></tr>
<tr class="memdesc:ac623fce02968881a5323c5892fed70fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the center of mass velocity Jacobian of the robot in robot base frame <br /></td></tr>
<tr class="separator:ac623fce02968881a5323c5892fed70fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ac21aa73d2468bf2afcf5ce0085ec" id="r_aba2ac21aa73d2468bf2afcf5ce0085ec"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aba2ac21aa73d2468bf2afcf5ce0085ec">taskInertiaMatrix</a> (const MatrixXd &amp;task_jacobian) const</td></tr>
<tr class="memdesc:aba2ac21aa73d2468bf2afcf5ce0085ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the operational space inertia matrix corresponding to a given Jacobian.  <br /></td></tr>
<tr class="separator:aba2ac21aa73d2468bf2afcf5ce0085ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078ec35d2429eb143cf47914b8dd5ba1" id="r_a078ec35d2429eb143cf47914b8dd5ba1"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a078ec35d2429eb143cf47914b8dd5ba1">taskInertiaMatrixWithPseudoInv</a> (const MatrixXd &amp;task_jacobian) const</td></tr>
<tr class="memdesc:a078ec35d2429eb143cf47914b8dd5ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the operational space inertia matrix robust to singularities by using the pseudo inverse of J*M^{-1}*J^T.  <br /></td></tr>
<tr class="separator:a078ec35d2429eb143cf47914b8dd5ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce0c2c745baada07b043e40dbad22d" id="r_ab9ce0c2c745baada07b043e40dbad22d"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ab9ce0c2c745baada07b043e40dbad22d">dynConsistentInverseJacobian</a> (const MatrixXd &amp;task_jacobian) const</td></tr>
<tr class="memdesc:ab9ce0c2c745baada07b043e40dbad22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dynamically consistent inverse of the jacobian for a given task. Recomputes the task inertia at each call.  <br /></td></tr>
<tr class="separator:ab9ce0c2c745baada07b043e40dbad22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad769c1699df5da3258c8b8e70c6f31f2" id="r_ad769c1699df5da3258c8b8e70c6f31f2"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ad769c1699df5da3258c8b8e70c6f31f2">nullspaceMatrix</a> (const MatrixXd &amp;task_jacobian) const</td></tr>
<tr class="memdesc:ad769c1699df5da3258c8b8e70c6f31f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dynamically consistent nullspace of the jacobian.  <br /></td></tr>
<tr class="separator:ad769c1699df5da3258c8b8e70c6f31f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0352194f2d3e15b3bb340851cc42ba" id="r_a5d0352194f2d3e15b3bb340851cc42ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSaiModel_1_1OpSpaceMatrices.html">OpSpaceMatrices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a5d0352194f2d3e15b3bb340851cc42ba">operationalSpaceMatrices</a> (const MatrixXd &amp;task_jacobian) const</td></tr>
<tr class="memdesc:a5d0352194f2d3e15b3bb340851cc42ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the operational space matrices (task inertia, dynamically consistent inverse of the jacobian and nullspace) for a given task. More efficient than calling the three individual functions because it avoids repeated computations.  <br /></td></tr>
<tr class="separator:a5d0352194f2d3e15b3bb340851cc42ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fe73c4642b0879cdc696e77155fe38" id="r_a86fe73c4642b0879cdc696e77155fe38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a86fe73c4642b0879cdc696e77155fe38">addEnvironmentalContact</a> (const string link, const Vector3d pos_in_link=Vector3d::Zero(), const Matrix3d orientation=Matrix3d::Identity(), const ContactType contact_type=ContactType::SurfaceContact)</td></tr>
<tr class="memdesc:a86fe73c4642b0879cdc696e77155fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an environmental contact to the desired link at the desired contact frame. There can only be one contact per link.  <br /></td></tr>
<tr class="separator:a86fe73c4642b0879cdc696e77155fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743a40f0962d77649e74c8d07847f761" id="r_a743a40f0962d77649e74c8d07847f761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a743a40f0962d77649e74c8d07847f761">addManipulationContact</a> (const string link, const Vector3d pos_in_link=Vector3d::Zero(), const Matrix3d orientation=Matrix3d::Identity(), const ContactType contact_type=ContactType::SurfaceContact)</td></tr>
<tr class="memdesc:a743a40f0962d77649e74c8d07847f761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a manipulation contact to the desired link at the desired contact frame. There can only be one contact per link.  <br /></td></tr>
<tr class="separator:a743a40f0962d77649e74c8d07847f761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d22946be6c804bedac72c9df5ee0f0" id="r_a58d22946be6c804bedac72c9df5ee0f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a58d22946be6c804bedac72c9df5ee0f0">updateEnvironmentalContact</a> (const string link, const Vector3d pos_in_link, const Matrix3d orientation, const ContactType contact_type)</td></tr>
<tr class="memdesc:a58d22946be6c804bedac72c9df5ee0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the environmental contact frame or type at the given link.  <br /></td></tr>
<tr class="separator:a58d22946be6c804bedac72c9df5ee0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45cc6d7459357064afcb133b87fb4d0" id="r_aa45cc6d7459357064afcb133b87fb4d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aa45cc6d7459357064afcb133b87fb4d0">updateManipulationContact</a> (const string link, const Vector3d pos_in_link, const Matrix3d orientation, const ContactType contact_type)</td></tr>
<tr class="memdesc:aa45cc6d7459357064afcb133b87fb4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the manipulation contact frame or type at the given link.  <br /></td></tr>
<tr class="separator:aa45cc6d7459357064afcb133b87fb4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194a90147d14000496a490fe0fc7bfd4" id="r_a194a90147d14000496a490fe0fc7bfd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a194a90147d14000496a490fe0fc7bfd4">deleteEnvironmentalContact</a> (const string link_name)</td></tr>
<tr class="memdesc:a194a90147d14000496a490fe0fc7bfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the environmental contact at a given link  <br /></td></tr>
<tr class="separator:a194a90147d14000496a490fe0fc7bfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4de9caae5d61678e91c3f8d32d876f" id="r_a6c4de9caae5d61678e91c3f8d32d876f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a6c4de9caae5d61678e91c3f8d32d876f">deleteManipulationContact</a> (const string link_name)</td></tr>
<tr class="memdesc:a6c4de9caae5d61678e91c3f8d32d876f"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the manipulation contact at a given link  <br /></td></tr>
<tr class="separator:a6c4de9caae5d61678e91c3f8d32d876f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af635bf614b615f79b7fd6b5955226" id="r_ae9af635bf614b615f79b7fd6b5955226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSaiModel_1_1GraspMatrixData.html">GraspMatrixData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#ae9af635bf614b615f79b7fd6b5955226">manipulationGraspMatrix</a> (const Vector3d &amp;center_point, const bool resultant_in_world_frame=false, const bool contact_forces_in_local_frames=false) const</td></tr>
<tr class="memdesc:ae9af635bf614b615f79b7fd6b5955226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the manipulation grasp matrix that converts contact forces expressed in robot frame (default), world frame or local contact frames into the resultant force expressed in robot frame (default) or world frame, and the internal froces and moments.  <br /></td></tr>
<tr class="separator:ae9af635bf614b615f79b7fd6b5955226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3961071a7970d1aa93a32f3dcf0ef97f" id="r_a3961071a7970d1aa93a32f3dcf0ef97f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSaiModel_1_1GraspMatrixData.html">GraspMatrixData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#a3961071a7970d1aa93a32f3dcf0ef97f">manipulationGraspMatrixAtGeometricCenter</a> (const bool resultant_in_world_frame=false, const bool contact_forces_in_local_frames=false) const</td></tr>
<tr class="memdesc:a3961071a7970d1aa93a32f3dcf0ef97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the manipulationGraspMatrix function, but the center_point is taken to be the geometric center of the contacts.  <br /></td></tr>
<tr class="separator:a3961071a7970d1aa93a32f3dcf0ef97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ff69640c3e335eb3d1916cb95039bc" id="r_aa4ff69640c3e335eb3d1916cb95039bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSaiModel_1_1GraspMatrixData.html">GraspMatrixData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#aa4ff69640c3e335eb3d1916cb95039bc">environmentalGraspMatrix</a> (const Vector3d &amp;center_point, const bool resultant_in_world_frame=false, const bool contact_forces_in_local_frames=false) const</td></tr>
<tr class="memdesc:aa4ff69640c3e335eb3d1916cb95039bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the environmental grasp matrix that converts contact forces expressed in robot frame (default), world frame or local contact frames into the resultant force expressed in robot frame (default) or world frame, and the internal froces and moments.  <br /></td></tr>
<tr class="separator:aa4ff69640c3e335eb3d1916cb95039bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31bad19b8ab432f6d6499de0d6f5a1c" id="r_af31bad19b8ab432f6d6499de0d6f5a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSaiModel_1_1GraspMatrixData.html">GraspMatrixData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSaiModel_1_1SaiModel.html#af31bad19b8ab432f6d6499de0d6f5a1c">environmentalGraspMatrixAtGeometricCenter</a> (const bool resultant_in_world_frame=false, const bool contact_forces_in_local_frames=false) const</td></tr>
<tr class="memdesc:af31bad19b8ab432f6d6499de0d6f5a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the environmentalGraspMatrix function, but the center_point is taken to be the geometric center of the contacts.  <br /></td></tr>
<tr class="separator:af31bad19b8ab432f6d6499de0d6f5a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07787ad9abc4c18377013cad0a1333cd" id="r_a07787ad9abc4c18377013cad0a1333cd"><td class="memItemLeft" align="right" valign="top"><a id="a07787ad9abc4c18377013cad0a1333cd" name="a07787ad9abc4c18377013cad0a1333cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>displayJoints</b> ()</td></tr>
<tr class="memdesc:a07787ad9abc4c18377013cad0a1333cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">print to terminal the joints of the robot with the corresponding numbers <br /></td></tr>
<tr class="separator:a07787ad9abc4c18377013cad0a1333cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad457b399f7d024276db50fefd64b85e1" id="r_ad457b399f7d024276db50fefd64b85e1"><td class="memItemLeft" align="right" valign="top"><a id="ad457b399f7d024276db50fefd64b85e1" name="ad457b399f7d024276db50fefd64b85e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>displayLinks</b> ()</td></tr>
<tr class="memdesc:ad457b399f7d024276db50fefd64b85e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">print to terminal the links of the robot with the corresponding numbers <br /></td></tr>
<tr class="separator:ad457b399f7d024276db50fefd64b85e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a robot kinematic and dynamic model and provides methods to compute many useful robot quantities, such as positions, velocities, jacobians, operational space matrices, grasp matrices, etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3231f5bd04e9e67f3287c3cf942892db" name="a3231f5bd04e9e67f3287c3cf942892db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3231f5bd04e9e67f3287c3cf942892db">&#9670;&#160;</a></span>SaiModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SaiModel::SaiModel::SaiModel </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>path_to_model_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Sai 2 Model object from a URDF file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_to_model_file</td><td>path to the URDF file </td></tr>
    <tr><td class="paramname">verbose</td><td>whether to print debug information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae208a7b8f61fe99b48082340bdf5f0f0" name="ae208a7b8f61fe99b48082340bdf5f0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae208a7b8f61fe99b48082340bdf5f0f0">&#9670;&#160;</a></span>acceleration6d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector6d SaiModel::SaiModel::acceleration6d </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the linear and angular acceleration of a point in a link. The returned value is expressed in the base frame and is of the form [a; alpha] (linear first, angular next). Note: Acceleration computations are very sensitive to frames being correct. So it is safer to call UpdateKinematics before calling this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link in which is the point where to compute the acceleration </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector6d linear and angular acceleration of the point in the link in robot base frame </dd></dl>

</div>
</div>
<a id="a4f15ca2a0abb8307032cf435be21b28e" name="a4f15ca2a0abb8307032cf435be21b28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f15ca2a0abb8307032cf435be21b28e">&#9670;&#160;</a></span>acceleration6dInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector6d SaiModel::SaiModel::acceleration6dInWorld </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the acceleration6d function, but the returned acceleration is in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link in which is the point where to compute the acceleration </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector6d linear and angular acceleration of the point in the link in world frame </dd></dl>

</div>
</div>
<a id="a86fe73c4642b0879cdc696e77155fe38" name="a86fe73c4642b0879cdc696e77155fe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fe73c4642b0879cdc696e77155fe38">&#9670;&#160;</a></span>addEnvironmentalContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiModel::SaiModel::addEnvironmentalContact </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d&#160;</td>
          <td class="paramname"><em>orientation</em> = <code>Matrix3d::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactType&#160;</td>
          <td class="paramname"><em>contact_type</em> = <code>ContactType::SurfaceContact</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an environmental contact to the desired link at the desired contact frame. There can only be one contact per link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">link</td><td>link at which the contact happens </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_in_link</td><td>position of the contact in the link in locallink frame </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>orientation of the contact frame in the link frame. Z axis needs to be aligned with the constrained direction of motion (surface normal) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contact_type</td><td>The contact type (surface or point) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a743a40f0962d77649e74c8d07847f761" name="a743a40f0962d77649e74c8d07847f761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743a40f0962d77649e74c8d07847f761">&#9670;&#160;</a></span>addManipulationContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiModel::SaiModel::addManipulationContact </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d&#160;</td>
          <td class="paramname"><em>orientation</em> = <code>Matrix3d::Identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactType&#160;</td>
          <td class="paramname"><em>contact_type</em> = <code>ContactType::SurfaceContact</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a manipulation contact to the desired link at the desired contact frame. There can only be one contact per link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">link</td><td>link at which the contact happens </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_in_link</td><td>position of the contact in the link in locallink frame </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>orientation of the contact frame in the link frame. Z axis needs to be aligned with the constrained direction of motion (surface normal) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contact_type</td><td>The contact type (surface or point) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af04cf4a2821952b69413c9ce43017529" name="af04cf4a2821952b69413c9ce43017529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04cf4a2821952b69413c9ce43017529">&#9670;&#160;</a></span>angularAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::angularAcceleration </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the angular Acceleration of a link (possibly a local frame expressed in link frame) with respect to base frame Note: Acceleration computations are very sensitive to frames being correct. So it is safer to call UpdateKinematics before calling this, unless this is called right after a simulator integrator state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">link_name</td><td>name of the link for which to compute the rotation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rot_in_link</td><td>Local frame of interest expressed in link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d angular acceleration of the link in robot base frame </dd></dl>

</div>
</div>
<a id="a025c0ca2d45c7d3a5e978dca3753207d" name="a025c0ca2d45c7d3a5e978dca3753207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025c0ca2d45c7d3a5e978dca3753207d">&#9670;&#160;</a></span>angularAccelerationInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::angularAccelerationInWorld </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the angularAcceleration function, but the returned angular acceleration is in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link for which to compute the rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d angular acceleration of the link in world frame </dd></dl>

</div>
</div>
<a id="a36bdf402ecf3b450c38a1c7376a5419e" name="a36bdf402ecf3b450c38a1c7376a5419e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bdf402ecf3b450c38a1c7376a5419e">&#9670;&#160;</a></span>angularVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::angularVelocity </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the angular Velocity of a link (possibly a local frame expressed in link frame) with respect to base frame (default) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">link_name</td><td>name of the link for which to compute the rotation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rot_in_link</td><td>Local frame of interest expressed in link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d angular velocity of the link in robot base frame </dd></dl>

</div>
</div>
<a id="ad0209c1c46fa9006ddbec1443109c394" name="ad0209c1c46fa9006ddbec1443109c394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0209c1c46fa9006ddbec1443109c394">&#9670;&#160;</a></span>angularVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::angularVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the angularVelocity function, but the returned angular velocity is in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link for which to compute the rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d angular velocity of the link in world frame </dd></dl>

</div>
</div>
<a id="adcba7dc8f3fc764e81237bae7a0e38c9" name="adcba7dc8f3fc764e81237bae7a0e38c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcba7dc8f3fc764e81237bae7a0e38c9">&#9670;&#160;</a></span>childLinkName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SaiModel::SaiModel::childLinkName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>joint_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the link directly attached to the given joint id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_name</td><td>name of the joint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child link name </dd></dl>

</div>
</div>
<a id="adca249ca7d43eff87fcf2936c5c4ca55" name="adca249ca7d43eff87fcf2936c5c4ca55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca249ca7d43eff87fcf2936c5c4ca55">&#9670;&#160;</a></span>computeInverseKinematics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd SaiModel::SaiModel::computeInverseKinematics </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>link_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Affine3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>frames_in_links</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Affine3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>desired_frames_locations_in_world_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse kinematics to get the robot configuration that matches a set of frames on some robot links to a set of desired frames. Uses the same underlying function as the previous function, but with frames instead of points. Uses the current joint positions as initial guess, and does not update the robot configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_names</td><td>vector of link names that contain the frames to match </td></tr>
    <tr><td class="paramname">frames_in_links</td><td>frames in the links </td></tr>
    <tr><td class="paramname">desired_frames_locations_in_world_frame</td><td>desired frames in world </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VectorXd set of joint angles that match the desired frames as best as possible </dd></dl>

</div>
</div>
<a id="af7e714659dd9956022f3a3aff3021269" name="af7e714659dd9956022f3a3aff3021269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e714659dd9956022f3a3aff3021269">&#9670;&#160;</a></span>computeInverseKinematics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd SaiModel::SaiModel::computeInverseKinematics </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>link_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos_in_links</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>desired_pos_world_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse kinematics to get the robot configuration that matches a set of points on the robot to desired positions. Uses a modified underlying RBDL function based on an iterative computation using the damped Levenberg-Marquardt method (also known as Damped Least Squares method) with output saturation for the joint limits. Always returns the value from the last iteration, even if the IK did not converge. Uses the current joint positions as initial guess, and does not update the robot configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_names</td><td>vector of link names that contain the points to match </td></tr>
    <tr><td class="paramname">pos_in_links</td><td>positions of the points in the links </td></tr>
    <tr><td class="paramname">desired_pos_world_frame</td><td>desired positions of the points in world frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VectorXd set of joint angles that match the desired points as best as possible </dd></dl>

</div>
</div>
<a id="a4de5bfad3ff71784bbc67be1e06c6fd0" name="a4de5bfad3ff71784bbc67be1e06c6fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de5bfad3ff71784bbc67be1e06c6fd0">&#9670;&#160;</a></span>coriolisForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd SaiModel::SaiModel::coriolisForce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes and returns the joint coriolis and centrifugal forces of the last updated configuration </p>
<dl class="section return"><dt>Returns</dt><dd>The joint coriolis and centrifugal forces </dd></dl>

</div>
</div>
<a id="a6c2af6f58d7cc1769e3aa84448e9aa87" name="a6c2af6f58d7cc1769e3aa84448e9aa87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2af6f58d7cc1769e3aa84448e9aa87">&#9670;&#160;</a></span>coriolisPlusGravity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd SaiModel::SaiModel::coriolisPlusGravity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the non linear effects of the robot dynamics. That is to say the gravity plus the coriolis and centrifugal forces. </p>
<dl class="section return"><dt>Returns</dt><dd>The non linear effects of the robot dynamics </dd></dl>

</div>
</div>
<a id="a194a90147d14000496a490fe0fc7bfd4" name="a194a90147d14000496a490fe0fc7bfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194a90147d14000496a490fe0fc7bfd4">&#9670;&#160;</a></span>deleteEnvironmentalContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiModel::SaiModel::deleteEnvironmentalContact </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes the environmental contact at a given link </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the link at which we want to delete the contact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c4de9caae5d61678e91c3f8d32d876f" name="a6c4de9caae5d61678e91c3f8d32d876f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4de9caae5d61678e91c3f8d32d876f">&#9670;&#160;</a></span>deleteManipulationContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiModel::SaiModel::deleteManipulationContact </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes the manipulation contact at a given link </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the link at which we want to delete the contact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab22a8ce4966e1186623d9171e50d9dd" name="aab22a8ce4966e1186623d9171e50d9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab22a8ce4966e1186623d9171e50d9dd">&#9670;&#160;</a></span>dof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; SaiModel::SaiModel::dof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of degrees of freedom of the robot </p>
<dl class="section return"><dt>Returns</dt><dd>number of dof of robot </dd></dl>

</div>
</div>
<a id="ab9ce0c2c745baada07b043e40dbad22d" name="ab9ce0c2c745baada07b043e40dbad22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ce0c2c745baada07b043e40dbad22d">&#9670;&#160;</a></span>dynConsistentInverseJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::dynConsistentInverseJacobian </td>
          <td>(</td>
          <td class="paramtype">const MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>task_jacobian</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the dynamically consistent inverse of the jacobian for a given task. Recomputes the task inertia at each call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_jacobian</td><td>The task jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dynamically consistent inverse jacobian </dd></dl>

</div>
</div>
<a id="aa4ff69640c3e335eb3d1916cb95039bc" name="aa4ff69640c3e335eb3d1916cb95039bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ff69640c3e335eb3d1916cb95039bc">&#9670;&#160;</a></span>environmentalGraspMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSaiModel_1_1GraspMatrixData.html">GraspMatrixData</a> SaiModel::SaiModel::environmentalGraspMatrix </td>
          <td>(</td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>center_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>resultant_in_world_frame</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>contact_forces_in_local_frames</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the environmental grasp matrix that converts contact forces expressed in robot frame (default), world frame or local contact frames into the resultant force expressed in robot frame (default) or world frame, and the internal froces and moments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center_point</td><td>the position (in robot or world frame) of the point on which we resolve the resultant forces </td></tr>
    <tr><td class="paramname">resultant_in_world_frame</td><td>if true, the resultant force is expressed in world frame, otherwise in robot frame </td></tr>
    <tr><td class="paramname">contact_forces_in_local_frames</td><td>if true, the contact forces are expressed in local contact frames, otherwise in robot frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structSaiModel_1_1GraspMatrixData.html" title="A structure to store the grasp matrix data.">GraspMatrixData</a> the structure containing the grasp matrix, its inverse and the rotation matrix of the grasp </dd></dl>

</div>
</div>
<a id="af31bad19b8ab432f6d6499de0d6f5a1c" name="af31bad19b8ab432f6d6499de0d6f5a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31bad19b8ab432f6d6499de0d6f5a1c">&#9670;&#160;</a></span>environmentalGraspMatrixAtGeometricCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSaiModel_1_1GraspMatrixData.html">GraspMatrixData</a> SaiModel::SaiModel::environmentalGraspMatrixAtGeometricCenter </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>resultant_in_world_frame</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>contact_forces_in_local_frames</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the environmentalGraspMatrix function, but the center_point is taken to be the geometric center of the contacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center_point</td><td>the position (in robot or world frame) of the point on which we resolve the resultant forces </td></tr>
    <tr><td class="paramname">resultant_in_world_frame</td><td>if true, the resultant force is expressed in world frame, otherwise in robot frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cf7a15e51067a46ad88c3c7847c295b" name="a3cf7a15e51067a46ad88c3c7847c295b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf7a15e51067a46ad88c3c7847c295b">&#9670;&#160;</a></span>factorizedChristoffelMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::factorizedChristoffelMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the matrix C such that the coriolis and centrifucal forces can be expressed b = C*q_dot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>return matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acecad858b6bebd2fc94552827559c3ef" name="acecad858b6bebd2fc94552827559c3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecad858b6bebd2fc94552827559c3ef">&#9670;&#160;</a></span>getLinkMassParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSaiModel_1_1LinkMassParams.html">LinkMassParams</a> SaiModel::SaiModel::getLinkMassParams </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the mass properties of a given link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>the returned mass value </td></tr>
    <tr><td class="paramname">center_of_mass</td><td>the returned position of the center of mass in the body's frame </td></tr>
    <tr><td class="paramname">inertia</td><td>the returned inertia of the given link </td></tr>
    <tr><td class="paramname">link_name</td><td>the name of the considered link </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c0499397118327680b13833fe90638e" name="a1c0499397118327680b13833fe90638e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0499397118327680b13833fe90638e">&#9670;&#160;</a></span>J()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::J </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full jacobian for link, relative to base (id=0) in the form [Jv; Jw] (angular first, linear next) expressed in robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link where the jacobian is computed (in local link frame) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>J Jacobian in the form [Jv, Jw] in robot base frame </dd></dl>

</div>
</div>
<a id="ae3a3928244fb207fdac9d308df470665" name="ae3a3928244fb207fdac9d308df470665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a3928244fb207fdac9d308df470665">&#9670;&#160;</a></span>JLocalFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::JLocalFrame </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>rot_in_link</em> = <code>Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the J function, but the returned jacobian is expressed in a local frame (with respect to the link frame) instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link where the jacobian is computed (in local link frame) </td></tr>
    <tr><td class="paramname">rot_in_link</td><td>the rotation of the local frame in the link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jacobian in the form [Jv, Jw] in local frame </dd></dl>

</div>
</div>
<a id="aa53c3862eccb309de7640a8c0cc7c8f8" name="aa53c3862eccb309de7640a8c0cc7c8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53c3862eccb309de7640a8c0cc7c8f8">&#9670;&#160;</a></span>jointGravityVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorXd SaiModel::SaiModel::jointGravityVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes and returns the joint gravity vector for the last updated configuration. This is the vector of torques required to compensate for the gravity forces acting on the robot. </p>
<dl class="section return"><dt>Returns</dt><dd>the joint gravity vector </dd></dl>

</div>
</div>
<a id="a65ec4fb2f3a20dc55ac34c3c98b7eaac" name="a65ec4fb2f3a20dc55ac34c3c98b7eaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ec4fb2f3a20dc55ac34c3c98b7eaac">&#9670;&#160;</a></span>jointIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SaiModel::SaiModel::jointIndex </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>joint_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the joint index for a given name. For spherical joints, returns the first index of the vector part of the quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_name</td><td>name of the joint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the joint index </dd></dl>

</div>
</div>
<a id="a740218bdf928e9f67735e6316c86a209" name="a740218bdf928e9f67735e6316c86a209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740218bdf928e9f67735e6316c86a209">&#9670;&#160;</a></span>jointLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="structSaiModel_1_1JointLimit.html">JointLimit</a> &gt; &amp; SaiModel::SaiModel::jointLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getter for the joint limits </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="structSaiModel_1_1JointLimit.html" title="A structure to store joint limits for a robot.">JointLimit</a> structures, one per joint </dd></dl>

</div>
</div>
<a id="abd7b9df768c2e4eaa547d181ca3984fe" name="abd7b9df768c2e4eaa547d181ca3984fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7b9df768c2e4eaa547d181ca3984fe">&#9670;&#160;</a></span>jointName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SaiModel::SaiModel::jointName </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>joint_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the joint name for the given index (for spherical joints, any index corresponding to the position of one of the quaternion coefficients will return the spherical joint name) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_id</td><td>index of the joint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string name of the joint </dd></dl>

</div>
</div>
<a id="ab6752408d68c17361a04e25ec42e393a" name="ab6752408d68c17361a04e25ec42e393a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6752408d68c17361a04e25ec42e393a">&#9670;&#160;</a></span>Jv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::Jv </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity jacobian for link, relative to base (id=0) expressed in robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link where the jacobian is computed (in local link frame) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MatrixXd linear velocity jacobian in robot base frame </dd></dl>

</div>
</div>
<a id="aab36f364dfb5ac7d7f264d6de16788bf" name="aab36f364dfb5ac7d7f264d6de16788bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab36f364dfb5ac7d7f264d6de16788bf">&#9670;&#160;</a></span>JvLocalFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::JvLocalFrame </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>rot_in_link</em> = <code>Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the Jv function, but the returned jacobian is expressed in a local frame (with respect to the link frame) instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link where the jacobian is computed (in local link frame) </td></tr>
    <tr><td class="paramname">rot_in_link</td><td>the rotation of the local frame in the link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MatrixXd linear velocity jacobian in local frame </dd></dl>

</div>
</div>
<a id="ae67c4ccb90f9f30709e1cfc4c3d26cb3" name="ae67c4ccb90f9f30709e1cfc4c3d26cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67c4ccb90f9f30709e1cfc4c3d26cb3">&#9670;&#160;</a></span>JvWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::JvWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the Jv function, but the returned jacobian is expressed in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link where the jacobian is computed (in local link frame) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MatrixXd linear velocity jacobian in world frame </dd></dl>

</div>
</div>
<a id="a7cbddeb81f4a996a6c903f6b755f65ef" name="a7cbddeb81f4a996a6c903f6b755f65ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbddeb81f4a996a6c903f6b755f65ef">&#9670;&#160;</a></span>Jw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::Jw </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Angular velocity jacobian for link, relative to base (id=0) expressed in robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MatrixXd angular velocity jacobian in robot base frame </dd></dl>

</div>
</div>
<a id="a66f09f8ffca0259d235cb3a641dfa11e" name="a66f09f8ffca0259d235cb3a641dfa11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f09f8ffca0259d235cb3a641dfa11e">&#9670;&#160;</a></span>JwLocalFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::JwLocalFrame </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>rot_in_link</em> = <code>Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the Jw function, but the returned jacobian is expressed in a local frame (with respect to the link frame) instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
    <tr><td class="paramname">rot_in_link</td><td>the rotation of the local frame in the link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MatrixXd angular velocity jacobian in local frame </dd></dl>

</div>
</div>
<a id="a6f0ba0a238efa96f833fc0368a181ff9" name="a6f0ba0a238efa96f833fc0368a181ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0ba0a238efa96f833fc0368a181ff9">&#9670;&#160;</a></span>JWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::JWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the J function, but the returned jacobian is expressed in the world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link where the jacobian is computed (in local link frame) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jacobian in the form [Jv, Jw] in world frame </dd></dl>

</div>
</div>
<a id="a297ca115e04ad10b592f3cc610497333" name="a297ca115e04ad10b592f3cc610497333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297ca115e04ad10b592f3cc610497333">&#9670;&#160;</a></span>JwWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::JwWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the Jw function, but the returned jacobian is expressed in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MatrixXd angular velocity jacobian in world frame </dd></dl>

</div>
</div>
<a id="a29be2741c8177c43361d26cebce1e0e8" name="a29be2741c8177c43361d26cebce1e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29be2741c8177c43361d26cebce1e0e8">&#9670;&#160;</a></span>linearAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::linearAcceleration </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the acceleration of point in link, in base coordinates Note: Acceleration computations are very sensitive to frames being correct. So it is safer to call UpdateKinematics before calling this, unless this is called right after a simulator integrator state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>name of the link in which is the point where to compute the velocity </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d acceleration of the point in the link in robot base frame </dd></dl>

</div>
</div>
<a id="adee710a5bd2f489a20805cbfe7d2e9dd" name="adee710a5bd2f489a20805cbfe7d2e9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee710a5bd2f489a20805cbfe7d2e9dd">&#9670;&#160;</a></span>linearAccelerationInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::linearAccelerationInWorld </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the linearAcceleration function, but the returned acceleration is in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link in which is the point where to compute the acceleration </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d acceleration of the point in the link in world frame </dd></dl>

</div>
</div>
<a id="abf6038147a812a7509c39034301bb801" name="abf6038147a812a7509c39034301bb801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6038147a812a7509c39034301bb801">&#9670;&#160;</a></span>linearVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::linearVelocity </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the velocity of point in link, in base coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>name of the link in which is the point where to compute the velocity </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d velocity of the point in the link in robot base </dd></dl>

</div>
</div>
<a id="a1bc094072c7d224b0361cf95f62ea21b" name="a1bc094072c7d224b0361cf95f62ea21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc094072c7d224b0361cf95f62ea21b">&#9670;&#160;</a></span>linearVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::linearVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the linearVelocity function, but the returned velocity is in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link in which is the point where to compute the velocity </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d velocity of the point in the link in world frame </dd></dl>

</div>
</div>
<a id="ae9af635bf614b615f79b7fd6b5955226" name="ae9af635bf614b615f79b7fd6b5955226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9af635bf614b615f79b7fd6b5955226">&#9670;&#160;</a></span>manipulationGraspMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSaiModel_1_1GraspMatrixData.html">GraspMatrixData</a> SaiModel::SaiModel::manipulationGraspMatrix </td>
          <td>(</td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>center_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>resultant_in_world_frame</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>contact_forces_in_local_frames</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the manipulation grasp matrix that converts contact forces expressed in robot frame (default), world frame or local contact frames into the resultant force expressed in robot frame (default) or world frame, and the internal froces and moments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center_point</td><td>the position (in robot or world frame) of the point on which we resolve the resultant forces </td></tr>
    <tr><td class="paramname">resultant_in_world_frame</td><td>if true, the resultant force is expressed in world frame, otherwise in robot frame </td></tr>
    <tr><td class="paramname">contact_forces_in_local_frames</td><td>if true, the contact forces are expressed in local contact frames, otherwise in robot frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structSaiModel_1_1GraspMatrixData.html" title="A structure to store the grasp matrix data.">GraspMatrixData</a> the structure containing the grasp matrix, its inverse and the rotation matrix of the grasp </dd></dl>

</div>
</div>
<a id="a3961071a7970d1aa93a32f3dcf0ef97f" name="a3961071a7970d1aa93a32f3dcf0ef97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3961071a7970d1aa93a32f3dcf0ef97f">&#9670;&#160;</a></span>manipulationGraspMatrixAtGeometricCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSaiModel_1_1GraspMatrixData.html">GraspMatrixData</a> SaiModel::SaiModel::manipulationGraspMatrixAtGeometricCenter </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>resultant_in_world_frame</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>contact_forces_in_local_frames</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the manipulationGraspMatrix function, but the center_point is taken to be the geometric center of the contacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center_point</td><td>the position (in robot or world frame) of the point on which we resolve the resultant forces </td></tr>
    <tr><td class="paramname">resultant_in_world_frame</td><td>if true, the resultant force is expressed in world frame, otherwise in robot frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad769c1699df5da3258c8b8e70c6f31f2" name="ad769c1699df5da3258c8b8e70c6f31f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad769c1699df5da3258c8b8e70c6f31f2">&#9670;&#160;</a></span>nullspaceMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::nullspaceMatrix </td>
          <td>(</td>
          <td class="paramtype">const MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>task_jacobian</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the dynamically consistent nullspace of the jacobian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_jacobian</td><td>The task jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dynamically consistent nullspace matrix </dd></dl>

</div>
</div>
<a id="a5d0352194f2d3e15b3bb340851cc42ba" name="a5d0352194f2d3e15b3bb340851cc42ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0352194f2d3e15b3bb340851cc42ba">&#9670;&#160;</a></span>operationalSpaceMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSaiModel_1_1OpSpaceMatrices.html">OpSpaceMatrices</a> SaiModel::SaiModel::operationalSpaceMatrices </td>
          <td>(</td>
          <td class="paramtype">const MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>task_jacobian</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the operational space matrices (task inertia, dynamically consistent inverse of the jacobian and nullspace) for a given task. More efficient than calling the three individual functions because it avoids repeated computations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_jacobian</td><td>Task jacobian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structSaiModel_1_1OpSpaceMatrices.html" title="A structure to store the operational space matrices.">OpSpaceMatrices</a> struct containing the task inertia, dynamically consistent inverse of the jacobian and nullspace </dd></dl>

</div>
</div>
<a id="a01e2133ede2458d440dcf1457b25ca69" name="a01e2133ede2458d440dcf1457b25ca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e2133ede2458d440dcf1457b25ca69">&#9670;&#160;</a></span>parentLinkName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SaiModel::SaiModel::parentLinkName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>joint_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the link name parent of the given joint id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_name</td><td>name of the joint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parent link name </dd></dl>

</div>
</div>
<a id="aa09dc9ccd7e2dfa67f386ed82f52c5a1" name="aa09dc9ccd7e2dfa67f386ed82f52c5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09dc9ccd7e2dfa67f386ed82f52c5a1">&#9670;&#160;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::position </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the position of a point in a link. The returned value is in the base frame by default. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link in which is the point where to compute the position </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d position of the point in the link in robot base frame </dd></dl>

</div>
</div>
<a id="aa0ff3c898a809cb1752a6271286424a5" name="aa0ff3c898a809cb1752a6271286424a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ff3c898a809cb1752a6271286424a5">&#9670;&#160;</a></span>positionInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3d SaiModel::SaiModel::positionInWorld </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the position function, but the returned position is in a world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link in which is the point where to compute the position </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector3d position of the point in the link in world frame </dd></dl>

</div>
</div>
<a id="ae9e246bd3b6c7ebcc5266f8a0f3e7633" name="ae9e246bd3b6c7ebcc5266f8a0f3e7633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e246bd3b6c7ebcc5266f8a0f3e7633">&#9670;&#160;</a></span>qSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; SaiModel::SaiModel::qSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of values required for robot joint positions description. equals dof unless spherical or floating joints are present. </p>
<dl class="section return"><dt>Returns</dt><dd>number of values required for robot joint positions description </dd></dl>

</div>
</div>
<a id="a868f5a5c5fd596db3b3f7853e7183905" name="a868f5a5c5fd596db3b3f7853e7183905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868f5a5c5fd596db3b3f7853e7183905">&#9670;&#160;</a></span>rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix3d SaiModel::SaiModel::rotation </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>rot_in_link</em> = <code>Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rotation of a link (possibly a local frame expressed in link frame) with respect to base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">link_name</td><td>name of the link for which to compute the rotation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rot_in_link</td><td>Local frame of interest expressed in link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix3d rotation of the link in robot base frame </dd></dl>

</div>
</div>
<a id="a0bb949c8cc13d5a10023fb3c307a6352" name="a0bb949c8cc13d5a10023fb3c307a6352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb949c8cc13d5a10023fb3c307a6352">&#9670;&#160;</a></span>rotationInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix3d SaiModel::SaiModel::rotationInWorld </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>rot_in_link</em> = <code>Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the rotation function, but the returned rotation is in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link for which to compute the rotation </td></tr>
    <tr><td class="paramname">rot_in_link</td><td>Local frame of interest expressed in link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix3d rotation of the link in world frame </dd></dl>

</div>
</div>
<a id="ab856039203502de4ee4fb2c294e9d338" name="ab856039203502de4ee4fb2c294e9d338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab856039203502de4ee4fb2c294e9d338">&#9670;&#160;</a></span>sphericalJointIndexW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SaiModel::SaiModel::sphericalJointIndexW </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>joint_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the scalar part of the quaternion for a spherical joint. Throws an error if the joint is not spherical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_name</td><td>name of the joint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the w coefficient of the quaternion </dd></dl>

</div>
</div>
<a id="aba2ac21aa73d2468bf2afcf5ce0085ec" name="aba2ac21aa73d2468bf2afcf5ce0085ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2ac21aa73d2468bf2afcf5ce0085ec">&#9670;&#160;</a></span>taskInertiaMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd SaiModel::SaiModel::taskInertiaMatrix </td>
          <td>(</td>
          <td class="paramtype">const MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>task_jacobian</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the operational space inertia matrix corresponding to a given Jacobian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_jacobian</td><td>The jacobian of the task for which we want the op space mass matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The operational space inertia matrix </dd></dl>

</div>
</div>
<a id="a078ec35d2429eb143cf47914b8dd5ba1" name="a078ec35d2429eb143cf47914b8dd5ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078ec35d2429eb143cf47914b8dd5ba1">&#9670;&#160;</a></span>taskInertiaMatrixWithPseudoInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd SaiModel::SaiModel::taskInertiaMatrixWithPseudoInv </td>
          <td>(</td>
          <td class="paramtype">const MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>task_jacobian</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the operational space inertia matrix robust to singularities by using the pseudo inverse of J*M^{-1}*J^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_jacobian</td><td>The jacobian of the task for which we want the op space mass matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The operational space inertia matrix </dd></dl>

</div>
</div>
<a id="a77ccfe97cc02632c0c1f66db1dcb1ce0" name="a77ccfe97cc02632c0c1f66db1dcb1ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ccfe97cc02632c0c1f66db1dcb1ce0">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Affine3d SaiModel::SaiModel::transform </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>rot_in_link</em> = <code>Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transformation from base to link frame (possibly a local frame expressed in link frame), in robot base base coordinates. This represents the operator that "moves" the base frame to the link frame, which also means it represents the coordinate transform matrix to express a point in base frame, if we know it in link frame: p_base = T * p_link </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>name of the link where to compute the transformation matrix </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>The position in local body coordinates </td></tr>
    <tr><td class="paramname">rot_in_link</td><td>The rotation in local body coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Affine3d The transfrom operator from base frame to link frame, or the coordinate change matrix from link frame to base frame </dd></dl>

</div>
</div>
<a id="a5cb999cbdf225cb5d330d456debfc32d" name="a5cb999cbdf225cb5d330d456debfc32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb999cbdf225cb5d330d456debfc32d">&#9670;&#160;</a></span>transformInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Affine3d SaiModel::SaiModel::transformInWorld </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>rot_in_link</em> = <code>Matrix3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the transform function, but the returned transformation is expressed in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link where to compute the transformation </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position in local body coordinates </td></tr>
    <tr><td class="paramname">rot_in_link</td><td>the rotation in local body coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Affine3d The transfrom operator from world frame to link frame. </dd></dl>

</div>
</div>
<a id="a58d22946be6c804bedac72c9df5ee0f0" name="a58d22946be6c804bedac72c9df5ee0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d22946be6c804bedac72c9df5ee0f0">&#9670;&#160;</a></span>updateEnvironmentalContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiModel::SaiModel::updateEnvironmentalContact </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d&#160;</td>
          <td class="paramname"><em>pos_in_link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactType&#160;</td>
          <td class="paramname"><em>contact_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the environmental contact frame or type at the given link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">link</td><td>The link </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_in_link</td><td>The position in link </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contact_type</td><td>The contact type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa45cc6d7459357064afcb133b87fb4d0" name="aa45cc6d7459357064afcb133b87fb4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45cc6d7459357064afcb133b87fb4d0">&#9670;&#160;</a></span>updateManipulationContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiModel::SaiModel::updateManipulationContact </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d&#160;</td>
          <td class="paramname"><em>pos_in_link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix3d&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContactType&#160;</td>
          <td class="paramname"><em>contact_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the manipulation contact frame or type at the given link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">link</td><td>The link </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos_in_link</td><td>The position in link </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orientation</td><td>The orientation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contact_type</td><td>The contact type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa29311864a2a56ba2082d32f69e5f824" name="aa29311864a2a56ba2082d32f69e5f824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29311864a2a56ba2082d32f69e5f824">&#9670;&#160;</a></span>updateModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SaiModel::SaiModel::updateModel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the kinematics and the inverse of the mass matrix with an externally provided mass matrix (for example from the robot's manufacturer API) insetad of computing the mass matrix from the urdf description of the robot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>externally provided mass matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9808cb34661b443a1d66dc6fe4e55ec7" name="a9808cb34661b443a1d66dc6fe4e55ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9808cb34661b443a1d66dc6fe4e55ec7">&#9670;&#160;</a></span>velocity6d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector6d SaiModel::SaiModel::velocity6d </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the linear and angular velocity of a point in a link. The returned value is expressed in the base frame and is of the form [v; w] (linear first, angular next) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link in which is the point where to compute the velocity </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector6d linear and angular velocity of the point in the link in robot base frame </dd></dl>

</div>
</div>
<a id="a6e109198073a151d82b2e3541e70f764" name="a6e109198073a151d82b2e3541e70f764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e109198073a151d82b2e3541e70f764">&#9670;&#160;</a></span>velocity6dInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector6d SaiModel::SaiModel::velocity6dInWorld </td>
          <td>(</td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3d &amp;&#160;</td>
          <td class="paramname"><em>pos_in_link</em> = <code>Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the velocity6d function, but the returned velocity is in world frame instead of the robot base frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_name</td><td>the name of the link in which is the point where to compute the velocity </td></tr>
    <tr><td class="paramname">pos_in_link</td><td>the position of the point in the link, in local link frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector6d linear and angular velocity of the point in the link in world frame </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/sai-model/sai-model/src/<a class="el" href="SaiModel_8h_source.html">SaiModel.h</a></li>
<li>/home/runner/work/sai-model/sai-model/src/<b>SaiModel.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
